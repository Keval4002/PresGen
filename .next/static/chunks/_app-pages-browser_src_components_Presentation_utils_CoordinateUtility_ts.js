"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_Presentation_utils_CoordinateUtility_ts"],{

/***/ "(app-pages-browser)/./src/components/Presentation/utils/CoordinateUtility.ts":
/*!****************************************************************!*\
  !*** ./src/components/Presentation/utils/CoordinateUtility.ts ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoordinateManager: () => (/* binding */ CoordinateManager),\n/* harmony export */   PPTX_DIMENSIONS: () => (/* binding */ PPTX_DIMENSIONS),\n/* harmony export */   PptxExportManager: () => (/* binding */ PptxExportManager)\n/* harmony export */ });\n/* harmony import */ var _Edit_CanvaTypesConst__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Edit/CanvaTypesConst */ \"(app-pages-browser)/./src/components/Presentation/Edit/CanvaTypesConst.ts\");\n\nconst PPTX_DIMENSIONS = {\n    WIDTH: 10,\n    HEIGHT: 5.625\n};\nclass CoordinateManager {\n    webToPptx(webCoords) {\n        if (!this.isValidWebCoordinate(webCoords)) return null;\n        const { x, y, w, h } = webCoords;\n        return {\n            x: x * PPTX_DIMENSIONS.WIDTH,\n            y: y * PPTX_DIMENSIONS.HEIGHT,\n            w: Math.min(w * PPTX_DIMENSIONS.WIDTH, PPTX_DIMENSIONS.WIDTH - x * PPTX_DIMENSIONS.WIDTH),\n            h: Math.min(h * PPTX_DIMENSIONS.HEIGHT, PPTX_DIMENSIONS.HEIGHT - y * PPTX_DIMENSIONS.HEIGHT)\n        };\n    }\n    isValidWebCoordinate(coords) {\n        if (!coords || typeof coords !== \"object\") return false;\n        const { x, y, w, h } = coords;\n        return [\n            x,\n            y,\n            w,\n            h\n        ].every((val)=>typeof val === \"number\" && isFinite(val)) && w >= 0 && h >= 0 && x >= 0 && x <= 1 && y >= 0 && y <= 1;\n    }\n    validateAndNormalizeLayout(layout) {\n        if (!layout || typeof layout !== \"object\") return null;\n        const validatedLayout = {};\n        for(const key in layout){\n            if (Object.prototype.hasOwnProperty.call(layout, key) && layout[key] && this.isValidWebCoordinate(layout[key])) {\n                validatedLayout[key] = layout[key];\n            }\n        }\n        return Object.keys(validatedLayout).length > 0 ? validatedLayout : null;\n    }\n    validateSlideMeasurements(measurements) {\n        if (!measurements) return false;\n        if (!measurements.title) return false;\n        for(const key in measurements){\n            if (!this.isValidWebCoordinate(measurements[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass PptxExportManager {\n    async exportSavedPresentation(data, theme) {\n        var _data_slides_, _data_slides;\n        // Ensure JSZip is loaded first\n        if ( true && !window.JSZip) {\n            await new Promise((resolve)=>{\n                const script = document.createElement(\"script\");\n                script.src = \"/jszip.min.js\";\n                script.onload = resolve;\n                document.body.appendChild(script);\n            });\n        }\n        // Then load pptxgenjs\n        if ( true && !window.PptxGenJS) {\n            await new Promise((resolve)=>{\n                const script = document.createElement(\"script\");\n                script.src = \"/pptxgen.min.js\";\n                script.onload = resolve;\n                document.body.appendChild(script);\n            });\n        }\n        const PptxGenJS = window.PptxGenJS;\n        const pptx = new PptxGenJS();\n        pptx.layout = 'LAYOUT_16x9';\n        pptx.title = ((_data_slides = data.slides) === null || _data_slides === void 0 ? void 0 : (_data_slides_ = _data_slides[0]) === null || _data_slides_ === void 0 ? void 0 : _data_slides_.title) || \"Presentation\";\n        data.slides.forEach((slideData)=>{\n            this.addSlideFromCanvasElements(pptx, slideData, theme);\n        });\n        await pptx.writeFile({\n            fileName: \"\".concat(pptx.title, \".pptx\")\n        });\n    }\n    addSlideFromCanvasElements(pptx, slideData, theme) {\n        var _slideData_canvasElements;\n        const slide = pptx.addSlide();\n        const backgroundHex = (theme === null || theme === void 0 ? void 0 : theme.background_color) || '#FFFFFF';\n        if (backgroundHex) {\n            slide.background = {\n                color: backgroundHex.replace(\"#\", \"\")\n            };\n        }\n        const hasTitleElement = (_slideData_canvasElements = slideData.canvasElements) === null || _slideData_canvasElements === void 0 ? void 0 : _slideData_canvasElements.some((el)=>el.type === 'text' && (el.text === slideData.title || el.isTitle));\n        if (slideData.title && !hasTitleElement) {\n            slide.addText(slideData.title, {\n                x: 0.5,\n                y: 0.25,\n                w: 9,\n                h: 0.75,\n                fontFace: (theme === null || theme === void 0 ? void 0 : theme.heading_font) || 'Arial',\n                fontSize: 24,\n                color: ((theme === null || theme === void 0 ? void 0 : theme.primary_color) || '000000').replace(\"#\", \"\"),\n                bold: true,\n                align: 'center',\n                valign: 'middle'\n            });\n        }\n        const canvasWidth = slideData.canvasWidth || _Edit_CanvaTypesConst__WEBPACK_IMPORTED_MODULE_0__.CANVAS_CONFIG.WIDTH;\n        const canvasHeight = slideData.canvasHeight || _Edit_CanvaTypesConst__WEBPACK_IMPORTED_MODULE_0__.CANVAS_CONFIG.HEIGHT;\n        (slideData.canvasElements || []).forEach((el)=>{\n            this.addCanvasElementToSlide(slide, el, theme, canvasWidth, canvasHeight);\n        });\n    }\n    addCanvasElementToSlide(slide, element, theme, canvasWidth, canvasHeight) {\n        const pptxCoords = this.canvasToPptxCoordinates(element, canvasWidth, canvasHeight);\n        switch(element.type){\n            case 'text':\n                this.addTextElementToSlide(slide, element, pptxCoords, theme, canvasWidth);\n                break;\n            case 'image':\n                this.addImageElementToSlide(slide, element, pptxCoords);\n                break;\n            case 'shape':\n                this.addShapeElementToSlide(slide, element, pptxCoords, theme);\n                break;\n            default:\n                break;\n        }\n    }\n    canvasToPptxCoordinates(element, canvasWidth, canvasHeight) {\n        const PPTX_WIDTH = 10;\n        const PPTX_HEIGHT = 5.625;\n        const scaleX = PPTX_WIDTH / canvasWidth;\n        const scaleY = PPTX_HEIGHT / canvasHeight;\n        const x = element.x * scaleX;\n        const y = element.y * scaleY;\n        const w = (element.width || 200) * scaleX;\n        const h = (element.height || 50) * scaleY;\n        return {\n            x,\n            y,\n            w,\n            h\n        };\n    }\n    addTextElementToSlide(slide, element, pptxCoords, theme, canvasWidth) {\n        const scale = 720 / canvasWidth;\n        const scaledFontSize = (element.fontSize || 18) * scale;\n        const color = (element.fill || (theme === null || theme === void 0 ? void 0 : theme.text_color) || '#000000').replace('#', '');\n        slide.addText(element.text || '', {\n            ...pptxCoords,\n            fontFace: element.fontFamily || (theme === null || theme === void 0 ? void 0 : theme.body_font) || 'Arial',\n            fontSize: scaledFontSize,\n            color: color,\n            bold: element.fontStyle === 'bold',\n            italic: element.fontStyle === 'italic',\n            align: element.align || 'left',\n            valign: element.verticalAlign || 'top',\n            bullet: !!element.bulleted,\n            transparency: typeof element.opacity === 'number' ? (1 - element.opacity) * 100 : 0,\n            rotate: element.rotation || 0\n        });\n    }\n    addImageElementToSlide(slide, element, pptxCoords) {\n        const imageOptions = {\n            x: pptxCoords.x,\n            y: pptxCoords.y,\n            sizing: {\n                type: 'cover',\n                w: pptxCoords.w,\n                h: pptxCoords.h\n            },\n            rotate: element.rotation || 0\n        };\n        if (typeof element.src === \"string\" && (element.src.startsWith(\"data:image/png\") || element.src.startsWith(\"data:image/jpeg\"))) {\n            imageOptions.data = element.src;\n            slide.addImage(imageOptions);\n        } else if (typeof element.src === \"string\" && (element.src.startsWith(\"http://\") || element.src.startsWith(\"https://\"))) {\n            imageOptions.path = element.src;\n            slide.addImage(imageOptions);\n        }\n    }\n    addShapeElementToSlide(slide, element, pptxCoords, theme) {\n        slide.addShape(element.shapeType || 'rect', {\n            ...pptxCoords,\n            fill: {\n                color: (element.fill || (theme === null || theme === void 0 ? void 0 : theme.primary_color) || '#000000').replace(\"#\", \"\")\n            },\n            line: {\n                color: (element.stroke || '#000000').replace(\"#\", \"\"),\n                width: element.strokeWidth || 0\n            },\n            rotate: element.rotation || 0\n        });\n    }\n    constructor(){\n    // Removed unused coordinateManager property\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1ByZXNlbnRhdGlvbi91dGlscy9Db29yZGluYXRlVXRpbGl0eS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdEO0FBR2pELE1BQU1DLGtCQUFrQjtJQUFFQyxPQUFPO0lBQUlDLFFBQVE7QUFBTSxFQUFFO0FBRXJELE1BQU1DO0lBQ1RDLFVBQVVDLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ0QsWUFBWSxPQUFPO1FBQ2xELE1BQU0sRUFBRUUsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUdMO1FBQ3ZCLE9BQU87WUFDSEUsR0FBR0EsSUFBSVAsZ0JBQWdCQyxLQUFLO1lBQzVCTyxHQUFHQSxJQUFJUixnQkFBZ0JFLE1BQU07WUFDbkNPLEdBQUdFLEtBQUtDLEdBQUcsQ0FDVEgsSUFBSVQsZ0JBQWdCQyxLQUFLLEVBQ3pCRCxnQkFBZ0JDLEtBQUssR0FBR00sSUFBSVAsZ0JBQWdCQyxLQUFLO1lBRW5EUyxHQUFHQyxLQUFLQyxHQUFHLENBQ1RGLElBQUlWLGdCQUFnQkUsTUFBTSxFQUMxQkYsZ0JBQWdCRSxNQUFNLEdBQUdNLElBQUlSLGdCQUFnQkUsTUFBTTtRQUVuRDtJQUNKO0lBRUFJLHFCQUFxQk8sTUFBTSxFQUFFO1FBQzdCLElBQUksQ0FBQ0EsVUFBVSxPQUFPQSxXQUFXLFVBQVUsT0FBTztRQUM5QyxNQUFNLEVBQUVOLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHRztRQUMzQixPQUNFO1lBQUNOO1lBQUdDO1lBQUdDO1lBQUdDO1NBQUUsQ0FBQ0ksS0FBSyxDQUFDLENBQUNDLE1BQVEsT0FBT0EsUUFBUSxZQUFZQyxTQUFTRCxTQUNoRU4sS0FBSyxLQUNMQyxLQUFLLEtBQ0xILEtBQUssS0FDTEEsS0FBSyxLQUNMQyxLQUFLLEtBQ0xBLEtBQUs7SUFFUDtJQUVBUywy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QzlFb0IsTUFBTXlELFFBQVEsQ0FBQ2hDLFFBQVFpQyxTQUFTLElBQUksUUFBUTtZQUMxQyxHQUFHaEMsVUFBVTtZQUNiYSxNQUFNO2dCQUFFbEMsT0FBTyxDQUFDb0IsUUFBUWMsSUFBSSxLQUFJM0Qsa0JBQUFBLDRCQUFBQSxNQUFPc0MsYUFBYSxLQUFJLFNBQVEsRUFBR1osT0FBTyxDQUFDLEtBQUs7WUFBSTtZQUNwRnFELE1BQU07Z0JBQUV0RCxPQUFPLENBQUNvQixRQUFRbUMsTUFBTSxJQUFJLFNBQVEsRUFBR3RELE9BQU8sQ0FBQyxLQUFLO2dCQUFLNkIsT0FBT1YsUUFBUW9DLFdBQVcsSUFBSTtZQUFFO1lBQy9GWCxRQUFRekIsUUFBUTBCLFFBQVEsSUFBSTtRQUM5QjtJQUNGO0lBL0lFVyxhQUFjO0lBQ1YsNENBQTRDO0lBQ2hEO0FBOElKIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFtYmFuXFxPbmVEcml2ZVxcRGVza3RvcFxcRm9sZGVyc1xcUHJlc0dlblxcc3JjXFxjb21wb25lbnRzXFxQcmVzZW50YXRpb25cXHV0aWxzXFxDb29yZGluYXRlVXRpbGl0eS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDQU5WQVNfQ09ORklHIH0gZnJvbSBcIi4uL0VkaXQvQ2FudmFUeXBlc0NvbnN0XCI7XG5pbXBvcnQgdHlwZSB7IFRoZW1lIH0gZnJvbSBcIi4uL2NsaWVudC1vbmx5L3R5cGVzXCI7XG5cbmV4cG9ydCBjb25zdCBQUFRYX0RJTUVOU0lPTlMgPSB7IFdJRFRIOiAxMCwgSEVJR0hUOiA1LjYyNSB9O1xuXG5leHBvcnQgY2xhc3MgQ29vcmRpbmF0ZU1hbmFnZXIge1xuICAgIHdlYlRvUHB0eCh3ZWJDb29yZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRXZWJDb29yZGluYXRlKHdlYkNvb3JkcykpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB7IHgsIHksIHcsIGggfSA9IHdlYkNvb3JkcztcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICB4OiB4ICogUFBUWF9ESU1FTlNJT05TLldJRFRILCBcbiAgICAgICAgICAgIHk6IHkgKiBQUFRYX0RJTUVOU0lPTlMuSEVJR0hULCBcbiAgICAgIHc6IE1hdGgubWluKFxuICAgICAgICB3ICogUFBUWF9ESU1FTlNJT05TLldJRFRILFxuICAgICAgICBQUFRYX0RJTUVOU0lPTlMuV0lEVEggLSB4ICogUFBUWF9ESU1FTlNJT05TLldJRFRIXG4gICAgICApLFxuICAgICAgaDogTWF0aC5taW4oXG4gICAgICAgIGggKiBQUFRYX0RJTUVOU0lPTlMuSEVJR0hULFxuICAgICAgICBQUFRYX0RJTUVOU0lPTlMuSEVJR0hUIC0geSAqIFBQVFhfRElNRU5TSU9OUy5IRUlHSFRcbiAgICAgICksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaXNWYWxpZFdlYkNvb3JkaW5hdGUoY29vcmRzKSB7XG4gICAgaWYgKCFjb29yZHMgfHwgdHlwZW9mIGNvb3JkcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB7IHgsIHksIHcsIGggfSA9IGNvb3JkcztcbiAgICByZXR1cm4gKFxuICAgICAgW3gsIHksIHcsIGhdLmV2ZXJ5KCh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsKSkgJiZcbiAgICAgIHcgPj0gMCAmJlxuICAgICAgaCA+PSAwICYmXG4gICAgICB4ID49IDAgJiZcbiAgICAgIHggPD0gMSAmJlxuICAgICAgeSA+PSAwICYmXG4gICAgICB5IDw9IDFcbiAgICApO1xuICAgIH1cblxuICAgIHZhbGlkYXRlQW5kTm9ybWFsaXplTGF5b3V0KGxheW91dCkge1xuICAgIGlmICghbGF5b3V0IHx8IHR5cGVvZiBsYXlvdXQgIT09IFwib2JqZWN0XCIpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRMYXlvdXQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbGF5b3V0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsYXlvdXQsIGtleSkgJiZcbiAgICAgICAgbGF5b3V0W2tleV0gJiZcbiAgICAgICAgdGhpcy5pc1ZhbGlkV2ViQ29vcmRpbmF0ZShsYXlvdXRba2V5XSlcbiAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlZExheW91dFtrZXldID0gbGF5b3V0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbGlkYXRlZExheW91dCkubGVuZ3RoID4gMCA/IHZhbGlkYXRlZExheW91dCA6IG51bGw7XG4gICAgfVxuXG4gIHZhbGlkYXRlU2xpZGVNZWFzdXJlbWVudHMobWVhc3VyZW1lbnRzKSB7XG4gICAgaWYgKCFtZWFzdXJlbWVudHMpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIW1lYXN1cmVtZW50cy50aXRsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVhc3VyZW1lbnRzKSB7XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZFdlYkNvb3JkaW5hdGUobWVhc3VyZW1lbnRzW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHB0eEV4cG9ydE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBSZW1vdmVkIHVudXNlZCBjb29yZGluYXRlTWFuYWdlciBwcm9wZXJ0eVxuICAgIH1cblxuICBhc3luYyBleHBvcnRTYXZlZFByZXNlbnRhdGlvbihkYXRhOiBhbnksIHRoZW1lOiBUaGVtZSkge1xuICAgICAgICAvLyBFbnN1cmUgSlNaaXAgaXMgbG9hZGVkIGZpcnN0XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICEod2luZG93IGFzIGFueSkuSlNaaXApIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQuc3JjID0gXCIvanN6aXAubWluLmpzXCI7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlbiBsb2FkIHBwdHhnZW5qc1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhKHdpbmRvdyBhcyBhbnkpLlBwdHhHZW5KUykge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5zcmMgPSBcIi9wcHR4Z2VuLm1pbi5qc1wiO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFBwdHhHZW5KUyA9ICh3aW5kb3cgYXMgYW55KS5QcHR4R2VuSlM7XG4gICAgICAgIGNvbnN0IHBwdHggPSBuZXcgUHB0eEdlbkpTKCk7XG4gICAgICAgIHBwdHgubGF5b3V0ID0gJ0xBWU9VVF8xNng5JztcbiAgICAgICAgcHB0eC50aXRsZSA9IGRhdGEuc2xpZGVzPy5bMF0/LnRpdGxlIHx8IFwiUHJlc2VudGF0aW9uXCI7XG5cbiAgICBkYXRhLnNsaWRlcy5mb3JFYWNoKChzbGlkZURhdGE6IGFueSkgPT4ge1xuICAgICAgdGhpcy5hZGRTbGlkZUZyb21DYW52YXNFbGVtZW50cyhwcHR4LCBzbGlkZURhdGEsIHRoZW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgcHB0eC53cml0ZUZpbGUoeyBmaWxlTmFtZTogYCR7cHB0eC50aXRsZX0ucHB0eGAgfSk7XG4gICAgfVxuXG4gIGFkZFNsaWRlRnJvbUNhbnZhc0VsZW1lbnRzKHBwdHg6IGFueSwgc2xpZGVEYXRhOiBhbnksIHRoZW1lOiBUaGVtZSkge1xuICAgICAgICBjb25zdCBzbGlkZSA9IHBwdHguYWRkU2xpZGUoKTtcbiAgICBjb25zdCBiYWNrZ3JvdW5kSGV4ID0gdGhlbWU/LmJhY2tncm91bmRfY29sb3IgfHwgJyNGRkZGRkYnO1xuICAgICAgICBpZiAoYmFja2dyb3VuZEhleCkge1xuICAgICAgICAgICAgc2xpZGUuYmFja2dyb3VuZCA9IHsgY29sb3I6IGJhY2tncm91bmRIZXgucmVwbGFjZShcIiNcIiwgXCJcIikgfTtcbiAgICAgICAgfVxuICAgIGNvbnN0IGhhc1RpdGxlRWxlbWVudCA9IHNsaWRlRGF0YS5jYW52YXNFbGVtZW50cz8uc29tZSgoZWw6IGFueSkgPT5cbiAgICAgIGVsLnR5cGUgPT09ICd0ZXh0JyAmJiAoZWwudGV4dCA9PT0gc2xpZGVEYXRhLnRpdGxlIHx8IGVsLmlzVGl0bGUpXG4gICAgKTtcbiAgICBpZiAoc2xpZGVEYXRhLnRpdGxlICYmICFoYXNUaXRsZUVsZW1lbnQpIHtcbiAgICAgIHNsaWRlLmFkZFRleHQoc2xpZGVEYXRhLnRpdGxlLCB7XG4gICAgICAgIHg6IDAuNSwgeTogMC4yNSwgdzogOSwgaDogMC43NSxcbiAgICAgICAgZm9udEZhY2U6IHRoZW1lPy5oZWFkaW5nX2ZvbnQgfHwgJ0FyaWFsJyxcbiAgICAgICAgZm9udFNpemU6IDI0LFxuICAgICAgICBjb2xvcjogKHRoZW1lPy5wcmltYXJ5X2NvbG9yIHx8ICcwMDAwMDAnKS5yZXBsYWNlKFwiI1wiLCBcIlwiKSxcbiAgICAgICAgYm9sZDogdHJ1ZSwgYWxpZ246ICdjZW50ZXInLCB2YWxpZ246ICdtaWRkbGUnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gc2xpZGVEYXRhLmNhbnZhc1dpZHRoIHx8IENBTlZBU19DT05GSUcuV0lEVEg7XG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gc2xpZGVEYXRhLmNhbnZhc0hlaWdodCB8fCBDQU5WQVNfQ09ORklHLkhFSUdIVDtcbiAgICAoc2xpZGVEYXRhLmNhbnZhc0VsZW1lbnRzIHx8IFtdKS5mb3JFYWNoKChlbDogYW55KSA9PiB7XG4gICAgICB0aGlzLmFkZENhbnZhc0VsZW1lbnRUb1NsaWRlKHNsaWRlLCBlbCwgdGhlbWUsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgIH0pO1xuICB9XG5cbiAgYWRkQ2FudmFzRWxlbWVudFRvU2xpZGUoc2xpZGU6IGFueSwgZWxlbWVudDogYW55LCB0aGVtZTogVGhlbWUsIGNhbnZhc1dpZHRoOiBudW1iZXIsIGNhbnZhc0hlaWdodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcHB0eENvb3JkcyA9IHRoaXMuY2FudmFzVG9QcHR4Q29vcmRpbmF0ZXMoZWxlbWVudCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgc3dpdGNoIChlbGVtZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICB0aGlzLmFkZFRleHRFbGVtZW50VG9TbGlkZShzbGlkZSwgZWxlbWVudCwgcHB0eENvb3JkcywgdGhlbWUsIGNhbnZhc1dpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIHRoaXMuYWRkSW1hZ2VFbGVtZW50VG9TbGlkZShzbGlkZSwgZWxlbWVudCwgcHB0eENvb3Jkcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2hhcGUnOlxuICAgICAgICB0aGlzLmFkZFNoYXBlRWxlbWVudFRvU2xpZGUoc2xpZGUsIGVsZW1lbnQsIHBwdHhDb29yZHMsIHRoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjYW52YXNUb1BwdHhDb29yZGluYXRlcyhlbGVtZW50OiBhbnksIGNhbnZhc1dpZHRoOiBudW1iZXIsIGNhbnZhc0hlaWdodDogbnVtYmVyKSB7XG4gICAgY29uc3QgUFBUWF9XSURUSCA9IDEwO1xuICAgIGNvbnN0IFBQVFhfSEVJR0hUID0gNS42MjU7XG4gICAgY29uc3Qgc2NhbGVYID0gUFBUWF9XSURUSCAvIGNhbnZhc1dpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IFBQVFhfSEVJR0hUIC8gY2FudmFzSGVpZ2h0O1xuICAgIGNvbnN0IHggPSBlbGVtZW50LnggKiBzY2FsZVg7XG4gICAgY29uc3QgeSA9IGVsZW1lbnQueSAqIHNjYWxlWTtcbiAgICBjb25zdCB3ID0gKGVsZW1lbnQud2lkdGggfHwgMjAwKSAqIHNjYWxlWDtcbiAgICBjb25zdCBoID0gKGVsZW1lbnQuaGVpZ2h0IHx8IDUwKSAqIHNjYWxlWTtcbiAgICByZXR1cm4geyB4LCB5LCB3LCBoIH07XG4gIH1cblxuICBhZGRUZXh0RWxlbWVudFRvU2xpZGUoc2xpZGU6IGFueSwgZWxlbWVudDogYW55LCBwcHR4Q29vcmRzOiBhbnksIHRoZW1lOiBUaGVtZSwgY2FudmFzV2lkdGg6IG51bWJlcikge1xuICAgIGNvbnN0IHNjYWxlID0gNzIwIC8gY2FudmFzV2lkdGg7XG4gICAgY29uc3Qgc2NhbGVkRm9udFNpemUgPSAoZWxlbWVudC5mb250U2l6ZSB8fCAxOCkgKiBzY2FsZTtcbiAgICBjb25zdCBjb2xvciA9IChlbGVtZW50LmZpbGwgfHwgdGhlbWU/LnRleHRfY29sb3IgfHwgJyMwMDAwMDAnKS5yZXBsYWNlKCcjJywgJycpO1xuICAgIFxuICAgIHNsaWRlLmFkZFRleHQoZWxlbWVudC50ZXh0IHx8ICcnLCB7XG4gICAgICAuLi5wcHR4Q29vcmRzLFxuICAgICAgZm9udEZhY2U6IGVsZW1lbnQuZm9udEZhbWlseSB8fCB0aGVtZT8uYm9keV9mb250IHx8ICdBcmlhbCcsXG4gICAgICBmb250U2l6ZTogc2NhbGVkRm9udFNpemUsXG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBib2xkOiBlbGVtZW50LmZvbnRTdHlsZSA9PT0gJ2JvbGQnLFxuICAgICAgaXRhbGljOiBlbGVtZW50LmZvbnRTdHlsZSA9PT0gJ2l0YWxpYycsXG4gICAgICBhbGlnbjogZWxlbWVudC5hbGlnbiB8fCAnbGVmdCcsXG4gICAgICB2YWxpZ246IGVsZW1lbnQudmVydGljYWxBbGlnbiB8fCAndG9wJyxcbiAgICAgIGJ1bGxldDogISFlbGVtZW50LmJ1bGxldGVkLFxuICAgICAgdHJhbnNwYXJlbmN5OiB0eXBlb2YgZWxlbWVudC5vcGFjaXR5ID09PSAnbnVtYmVyJyA/ICgxIC0gZWxlbWVudC5vcGFjaXR5KSAqIDEwMCA6IDAsXG4gICAgICByb3RhdGU6IGVsZW1lbnQucm90YXRpb24gfHwgMCxcbiAgICB9KTtcbiAgfVxuXG4gIGFkZEltYWdlRWxlbWVudFRvU2xpZGUoc2xpZGU6IGFueSwgZWxlbWVudDogYW55LCBwcHR4Q29vcmRzOiBhbnkpIHtcbiAgICBjb25zdCBpbWFnZU9wdGlvbnMgPSB7XG4gICAgICAgIHg6IHBwdHhDb29yZHMueCxcbiAgICAgICAgeTogcHB0eENvb3Jkcy55LFxuICAgICAgICBzaXppbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb3ZlcicsXG4gICAgICAgICAgICB3OiBwcHR4Q29vcmRzLncsXG4gICAgICAgICAgICBoOiBwcHR4Q29vcmRzLmgsXG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0ZTogZWxlbWVudC5yb3RhdGlvbiB8fCAwLFxuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZWxlbWVudC5zcmMgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgIChlbGVtZW50LnNyYy5zdGFydHNXaXRoKFwiZGF0YTppbWFnZS9wbmdcIikgfHwgZWxlbWVudC5zcmMuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2UvanBlZ1wiKSlcbiAgICApIHtcbiAgICAgICAgKGltYWdlT3B0aW9ucyBhcyBhbnkpLmRhdGEgPSBlbGVtZW50LnNyYztcbiAgICAgICAgc2xpZGUuYWRkSW1hZ2UoaW1hZ2VPcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHlwZW9mIGVsZW1lbnQuc3JjID09PSBcInN0cmluZ1wiICYmXG4gICAgICAoZWxlbWVudC5zcmMuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgZWxlbWVudC5zcmMuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKVxuICAgICkge1xuICAgICAgICAoaW1hZ2VPcHRpb25zIGFzIGFueSkucGF0aCA9IGVsZW1lbnQuc3JjO1xuICAgICAgICBzbGlkZS5hZGRJbWFnZShpbWFnZU9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGFkZFNoYXBlRWxlbWVudFRvU2xpZGUoc2xpZGU6IGFueSwgZWxlbWVudDogYW55LCBwcHR4Q29vcmRzOiBhbnksIHRoZW1lOiBUaGVtZSkge1xuICAgIHNsaWRlLmFkZFNoYXBlKGVsZW1lbnQuc2hhcGVUeXBlIHx8ICdyZWN0Jywge1xuICAgICAgLi4ucHB0eENvb3JkcyxcbiAgICAgIGZpbGw6IHsgY29sb3I6IChlbGVtZW50LmZpbGwgfHwgdGhlbWU/LnByaW1hcnlfY29sb3IgfHwgJyMwMDAwMDAnKS5yZXBsYWNlKFwiI1wiLCBcIlwiKSB9LFxuICAgICAgbGluZTogeyBjb2xvcjogKGVsZW1lbnQuc3Ryb2tlIHx8ICcjMDAwMDAwJykucmVwbGFjZShcIiNcIiwgXCJcIiksIHdpZHRoOiBlbGVtZW50LnN0cm9rZVdpZHRoIHx8IDAgfSxcbiAgICAgIHJvdGF0ZTogZWxlbWVudC5yb3RhdGlvbiB8fCAwLFxuICAgIH0pO1xuICB9XG59Il0sIm5hbWVzIjpbIkNBTlZBU19DT05GSUciLCJQUFRYX0RJTUVOU0lPTlMiLCJXSURUSCIsIkhFSUdIVCIsIkNvb3JkaW5hdGVNYW5hZ2VyIiwid2ViVG9QcHR4Iiwid2ViQ29vcmRzIiwiaXNWYWxpZFdlYkNvb3JkaW5hdGUiLCJ4IiwieSIsInciLCJoIiwiTWF0aCIsIm1pbiIsImNvb3JkcyIsImV2ZXJ5IiwidmFsIiwiaXNGaW5pdGUiLCJ2YWxpZGF0ZUFuZE5vcm1hbGl6ZUxheW91dCIsImxheW91dCIsInZhbGlkYXRlZExheW91dCIsImtleSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImtleXMiLCJsZW5ndGgiLCJ2YWxpZGF0ZVNsaWRlTWVhc3VyZW1lbnRzIiwibWVhc3VyZW1lbnRzIiwidGl0bGUiLCJQcHR4RXhwb3J0TWFuYWdlciIsImV4cG9ydFNhdmVkUHJlc2VudGF0aW9uIiwiZGF0YSIsInRoZW1lIiwid2luZG93IiwiSlNaaXAiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNjcmlwdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsIm9ubG9hZCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIlBwdHhHZW5KUyIsInBwdHgiLCJzbGlkZXMiLCJmb3JFYWNoIiwic2xpZGVEYXRhIiwiYWRkU2xpZGVGcm9tQ2FudmFzRWxlbWVudHMiLCJ3cml0ZUZpbGUiLCJmaWxlTmFtZSIsInNsaWRlIiwiYWRkU2xpZGUiLCJiYWNrZ3JvdW5kSGV4IiwiYmFja2dyb3VuZF9jb2xvciIsImJhY2tncm91bmQiLCJjb2xvciIsInJlcGxhY2UiLCJoYXNUaXRsZUVsZW1lbnQiLCJjYW52YXNFbGVtZW50cyIsInNvbWUiLCJlbCIsInR5cGUiLCJ0ZXh0IiwiaXNUaXRsZSIsImFkZFRleHQiLCJmb250RmFjZSIsImhlYWRpbmdfZm9udCIsImZvbnRTaXplIiwicHJpbWFyeV9jb2xvciIsImJvbGQiLCJhbGlnbiIsInZhbGlnbiIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiYWRkQ2FudmFzRWxlbWVudFRvU2xpZGUiLCJlbGVtZW50IiwicHB0eENvb3JkcyIsImNhbnZhc1RvUHB0eENvb3JkaW5hdGVzIiwiYWRkVGV4dEVsZW1lbnRUb1NsaWRlIiwiYWRkSW1hZ2VFbGVtZW50VG9TbGlkZSIsImFkZFNoYXBlRWxlbWVudFRvU2xpZGUiLCJQUFRYX1dJRFRIIiwiUFBUWF9IRUlHSFQiLCJzY2FsZVgiLCJzY2FsZVkiLCJ3aWR0aCIsImhlaWdodCIsInNjYWxlIiwic2NhbGVkRm9udFNpemUiLCJmaWxsIiwidGV4dF9jb2xvciIsImZvbnRGYW1pbHkiLCJib2R5X2ZvbnQiLCJmb250U3R5bGUiLCJpdGFsaWMiLCJ2ZXJ0aWNhbEFsaWduIiwiYnVsbGV0IiwiYnVsbGV0ZWQiLCJ0cmFuc3BhcmVuY3kiLCJvcGFjaXR5Iiwicm90YXRlIiwicm90YXRpb24iLCJpbWFnZU9wdGlvbnMiLCJzaXppbmciLCJzdGFydHNXaXRoIiwiYWRkSW1hZ2UiLCJwYXRoIiwiYWRkU2hhcGUiLCJzaGFwZVR5cGUiLCJsaW5lIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJjb25zdHJ1Y3RvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Presentation/utils/CoordinateUtility.ts\n"));

/***/ })

}]);
import {
  generateImageWithFallbacks,
  getFallbackImageUrl,
} from "../utils/pollinationApi.js";
import pLimit from "p-limit";

/**
 * Enrich slides with generated image URLs.
 * @param {Array} slides - Slides generated by geminiAgent1
 * @returns {Promise<Array>} - Slides with imageUrl added
 */

const limit = pLimit(3); // Reduced concurrency to avoid overwhelming the API

// Retry function for failed image generation (now with multiple services)
async function retryImageGeneration(prompt, slideNumber = 0, maxRetries = 2) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(
        `Attempting image generation (attempt ${attempt}/${maxRetries}) for slide ${
          slideNumber + 1
        }, prompt: "${prompt}"`
      );
      const imageUrl = await generateImageWithFallbacks({
        prompt,
        slideNumber,
      });
      console.log(
        `✅ Image generated successfully on attempt ${attempt} for slide ${
          slideNumber + 1
        }`
      );
      return imageUrl;
    } catch (error) {
      console.error(
        `❌ Image generation failed on attempt ${attempt} for slide ${
          slideNumber + 1
        }:`,
        error.message
      );

      if (attempt === maxRetries) {
        throw error; // Re-throw on final attempt
      }

      // Wait before retrying (exponential backoff)
      const waitTime = Math.pow(2, attempt) * 1000; // 2s, 4s
      console.log(`⏳ Waiting ${waitTime}ms before retry...`);
      await new Promise((resolve) => setTimeout(resolve, waitTime));
    }
  }
}

async function geminiAgent3(slides) {
  const imagePromises = slides.map((slide, index) =>
    limit(async () => {
      try {
        const prompt =
          slide.imageSuggestion?.description ||
          "abstract digital art for a presentation slide";
        const imageUrl = await retryImageGeneration(prompt, index);

        return {
          ...slide,
          imageSuggestion: { ...slide.imageSuggestion, imageUrl },
          imageUrl: imageUrl, // Add imageUrl to top level for easier access
          imagePending: false,
          imageError: null,
        };
      } catch (error) {
        console.error(
          `❌ All image generation attempts failed for slide ${
            slide.slideNumber || index + 1
          }:`,
          error.message
        );

        // Get fallback image URL
        const prompt =
          slide.imageSuggestion?.description ||
          "abstract digital art for a presentation slide";
        const fallbackUrl = getFallbackImageUrl(prompt);

        // Return slide with fallback placeholder and error info
        return {
          ...slide,
          imageSuggestion: {
            ...slide.imageSuggestion,
            imageUrl: fallbackUrl,
            error: error.message,
          },
          imageUrl: fallbackUrl,
          imagePending: false, // No longer pending since we've given up
          imageError: error.message,
          // Add a fallback placeholder image URL
          fallbackImageUrl: fallbackUrl,
        };
      }
    })
  );

  const results = await Promise.allSettled(imagePromises);

  return results.map((result, index) => {
    if (result.status === "fulfilled") {
      return result.value;
    }

    // If the entire promise failed (shouldn't happen with our error handling)
    console.error(
      `Unexpected error for slide ${slides[index].slideNumber || index + 1}:`,
      result.reason
    );

    const prompt =
      slides[index].imageSuggestion?.description ||
      "abstract digital art for a presentation slide";
    const fallbackUrl = getFallbackImageUrl(prompt);

    return {
      ...slides[index],
      imageSuggestion: {
        ...slides[index].imageSuggestion,
        imageUrl: fallbackUrl,
        error: "Unexpected error occurred",
      },
      imageUrl: fallbackUrl,
      imagePending: false,
      imageError: "Unexpected error occurred",
      fallbackImageUrl: fallbackUrl,
    };
  });
}

export { geminiAgent3 };
